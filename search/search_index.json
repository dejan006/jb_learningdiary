{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JB Learning Diary - Dejan","text":"<p>This is a learning diary. It contains everything important I learned or practiced in the last months since February 2025.</p>"},{"location":"aic/","title":"Automate Infrastructure Concepts","text":""},{"location":"aic/#concept-1-vro","title":"Concept 1: VRO","text":"<p>VRO executes / implements workflows such as setting up a server or a VM after it has been requested by a person.</p> <p>Workflow:  - Flowchart with start and end and intermediate steps such as approvals, setting up VMs, active directories, etc. - Shows what needs to be done. </p> <p>---&gt; Problem: They put things there, but leave them there without further support</p> <p>---&gt; To solve this there is a second option: Fleet commander</p>"},{"location":"aic/#concept-2-fleet-commander","title":"Concept 2: Fleet Commander","text":"<p>If a User requests a VM with customized sizes of CPU, etc., he has to do it now in Git and not in form of a Workflow (Clicking on a UI).</p> <p>---&gt; Advantage: This requested stays there and will not be forgotten after some time (3 weeks for example).</p> <p>Now the Commander can read this wish request and decomposes it. For example he takes the wish for a VM and decomposes it into multiple Units: Active Directory, Network and VM). The Unit takes the blueprint and knows what they have to do.</p> <p>The method that Fleet Commander uses is called \"reconciliation\". Reconciliation defines de desired state and tries to get there step-wise, without losing the original state.</p>"},{"location":"aic/#first-difference","title":"First Difference","text":"<ul> <li>In the first concept, the owner can say \"I want it like that\" and the team has to do the entire job. </li> <li>With second Method out team does the Commander part and helps with a Unit, but each Owner has to do their own Unit.</li> </ul>"},{"location":"aic/#second-difference","title":"Second Difference","text":"<p>I mentioned that the request is not in the Git and won't be forgotten after some time. This gives the opportunity to change something and it will be automatically changed for everything, because the commander goes through it every few minutes and sees if something needs to be changed. Also if I delete something the commander will see that something is missing and will just replace it with a new one. In the first concept I would have to create a ticket for example and mistakes can happen.</p>"},{"location":"aic/#notes","title":"Notes","text":"<p>Link for reading more about reconciliation: https://release-1-6.cluster-api.sigs.k8s.io/developer/providers/implementers-guide/controllers_and_reconciliation</p>"},{"location":"bash/","title":"Bash","text":"<p>Basic Commands:</p> Command Definition pwd shows current directory ls lists all files in current directory ls -l lists all files with more details (rights, etc.) mkdir create empty folder rmdir delete empty folder touch create file (\"touch test.txt\") cat filename shows contents of a file cat filename filename2 shows multiple files rm delete file rm -r foldername delete folder (-r = recursive) mv rename file / move file (\"mv test.txt foldername\") mv -r move folder (\"mv foldername foldername2\") echo gives the echo back echo \"Hallo\" &gt; test.txt overwrites the file with \"Hallo\" echo \"Hallo\" &gt;&gt; test.txt Adds \"Hallo\" to the file ping url test status of website cp filename foldername copy file copy -r foldername foldername copy folder if fi syntax for if grep \"text\" test.txt search for something specific (\"text\") in a file history command history clear clear terminal"},{"location":"bash/#linux-man-pages-quick-guide","title":"Linux Man Pages \u2013 Quick Guide","text":"<p>Linux man pages (manual pages) are built-in documentation for commands, functions, config files, and more. You access them via the <code>man</code> command in the terminal.</p>"},{"location":"bash/#basic-usage","title":"Basic Usage","text":"<pre><code>man &lt;command&gt;\nExample: man ls\n</code></pre>"},{"location":"bash/#if-example","title":"If Example","text":"<pre><code>if [ Bedingung ]; then\n  # Code \nfi\n\n# Example\nzahl=10\nif [ \"$zahl\" -gt 5 ]; then\n    echo \"Die Zahl ist gr\u00f6\u00dfer als 5\"\nfi\n</code></pre>"},{"location":"golang/","title":"Table-Driven Tests in Go (Einfach erkl\u00e4rt)","text":""},{"location":"golang/#idee","title":"Idee","text":"<ul> <li>Statt viele einzelne Tests zu schreiben, legt man eine Tabelle mit Testf\u00e4llen an.</li> <li>Dann geht eine Schleife durch diese Tabelle und pr\u00fcft alles automatisch.</li> <li>Ergebnis: Weniger Code, \u00fcbersichtlicher, leichter zu erweitern.</li> </ul>"},{"location":"golang/#einzelne-tests-klassisch","title":"Einzelne Tests (klassisch)","text":"<pre><code>if Sum(1, 2) != 3 {\n    t.Error(\"Expected 3\")\n}\nif Sum(2, 2) != 4 {\n    t.Error(\"Expected 4\")\n}\nif Sum(5, 5) != 10 {\n    t.Error(\"Expected 10\")\n}\n</code></pre> <ul> <li>Jeder Test ist separat geschrieben.</li> <li>Viel wiederholter Code.</li> </ul>"},{"location":"golang/#table-driven-tests-besser","title":"Table-Driven Tests (besser)","text":"<pre><code>var tests = []struct {\n    a, b int\n    want int\n}{\n    {1, 2, 3},\n    {2, 2, 4},\n    {5, 5, 10},\n}\nfor _, tt := range tests {\n    got := Sum(tt.a, tt.b)\n    if got != tt.want {\n        t.Errorf(\"Sum(%d, %d) = %d; want %d\", tt.a, tt.b, got, tt.want)\n    }\n}\n</code></pre> <ul> <li>Alle Testf\u00e4lle sind in einer Liste gespeichert.</li> <li>Eine Schleife pr\u00fcft automatisch jeden Fall.</li> <li>Neue Tests einfach hinzuf\u00fcgen.</li> </ul>"},{"location":"golang/#vorteile","title":"Vorteile","text":"<ul> <li>Einfach neue Tests erg\u00e4nzen</li> <li>Weniger Fehler</li> <li>Bessere \u00dcbersicht</li> <li>K\u00fcrzerer Code</li> </ul>"},{"location":"kubectl/","title":"Kubernetes Objects","text":""},{"location":"kubectl/#what-are-kubernetes-objects","title":"What Are Kubernetes Objects?","text":"<p>In Kubernetes, there are objects that define how a cluster should look. They store information about what should run, how it should run, and how many resources can be used.</p> <p>Examples of information stored in an object: - Which app should run? - How many copies (replicas) should there be? - What rules apply (e.g. restart on failure)?</p> <p>An object is like a wish list \u2013 Kubernetes calls this the \"desired state\". Kubernetes takes care of making sure that everything runs exactly as described. If something goes wrong (e.g. a container crashes), it will automatically be fixed.</p>"},{"location":"kubectl/#how-does-kubernetes-work-with-that","title":"How Does Kubernetes Work With That?","text":"<p>Every object has two important parts: - <code>spec</code>: what you want (the desired state) - <code>status</code>: what is actually happening</p> <p>Kubernetes constantly compares these two and brings the system back to the desired state.</p>"},{"location":"kubectl/#how-do-you-create-an-object","title":"How Do You Create an Object?","text":"<p>You can create an object using the command line tool <code>kubectl</code>, for example:</p> <pre><code>kubectl apply -f test.yaml\n</code></pre>"},{"location":"linuxfilesystem/","title":"Linux Filesystem","text":"<p>The Linux file system is place in a computer, in which all files and programs are neatly stored. It's like a tree, where the tree trunk is called \"root\" and the leaves are all the other files and programs.</p>"},{"location":"linuxfilesystem/#heres-a-picture-of-it-to-understand-it-better","title":"Here's a picture of it to understand it better:","text":""},{"location":"linuxfilesystem/#filesystem-explained","title":"Filesystem Explained:","text":""},{"location":"linuxfilesystem/#bin","title":"/bin:","text":"<ul> <li>Contains fundamental user commands</li> <li>These commands provide the basic functionality to interact with the filesystem</li> <li>Examples: ls, cat, cp, etc.</li> </ul>"},{"location":"linuxfilesystem/#boot","title":"/boot:","text":"<ul> <li>Stores files needed to start the system</li> <li>Contains the Linux kernel and bootloader settings</li> </ul>"},{"location":"linuxfilesystem/#dev","title":"/dev:","text":"<ul> <li>Represents hardware devices as files</li> <li>Lets programs interact with hardware like hard drives or keyboards</li> </ul>"},{"location":"linuxfilesystem/#etc","title":"/etc:","text":"<ul> <li>Keeps system and application settings</li> <li>Contains configuration files that control how the system works</li> </ul>"},{"location":"linuxfilesystem/#home","title":"/home:","text":"<ul> <li>Contains personal directories for users (each user has one)</li> <li>Stores user-specific files, documents, and settings</li> <li>Provides separation for user data and ensures security</li> </ul>"},{"location":"linuxfilesystem/#lib","title":"/lib:","text":"<ul> <li>Contains shared library images needed to boot the system and run the commands in the root filesystem</li> </ul>"},{"location":"linuxfilesystem/#media-mnt","title":"/media &amp; /mnt:","text":"<ul> <li>Used for mounting external and temporary filesystems</li> <li>/media: typically for removable media like USB drives</li> <li>/mnt: for temporary filesystems, such as network shares, etc.</li> </ul>"},{"location":"linuxfilesystem/#opt","title":"/opt:","text":"<ul> <li>Designed for optional, third-party software installations</li> <li>Examples: Google Chrome, Webex, etc.</li> </ul>"},{"location":"linuxfilesystem/#sbin","title":"/sbin:","text":"<ul> <li>Holds system tools for administrators</li> <li>Used for managing disks, networks, and system settings</li> </ul>"},{"location":"linuxfilesystem/#usr","title":"/usr:","text":"<ul> <li>Stores programs and files for users</li> <li>Includes applications, libraries, etc.</li> <li>Example: programming languages like python, etc.</li> </ul>"},{"location":"linuxfilesystem/#var","title":"/var:","text":"<ul> <li>Holds variable data that grows over time</li> <li>Includes logs, temporary files, etc.</li> </ul>"},{"location":"linuxfilesystem/#tmp","title":"/tmp:","text":"<ul> <li>For temporary files</li> <li>Files are typically deleted after a reboot or after certain period</li> </ul>"},{"location":"oop/","title":"Object-Oriented Programming (OOP)","text":""},{"location":"oop/#introduction","title":"Introduction","text":"<p>When all functions and variables are placed in a single file without any structure, things can quickly become chaotic. Code becomes difficult to manage, hard to maintain, and prone to errors. This is where object-oriented programming (OOP) comes in.</p> <p>OOP helps us structure programs into logically separated objects. Each object is a combination of:</p> <ul> <li>Attributes (variables that describe the state)</li> <li>Methods (functions that define behavior)</li> </ul> <p>This results in cleaner, reusable, and maintainable code.</p>"},{"location":"oop/#what-is-an-object","title":"What is an Object?","text":"<p>An object is like a \"mini-program\" in itself. It contains both data and the functions that operate on that data.</p>"},{"location":"oop/#example-a-car-as-an-object","title":"Example: A Car as an Object","text":"<p>Let\u2019s take a car as an example of an object. A car has certain properties (attributes) and certain capabilities (methods):</p> <ul> <li>Attributes: <code>model</code>, <code>color</code></li> <li>Methods: <code>startCar()</code>, <code>turnOffCar()</code></li> </ul>"},{"location":"oop/#code-example","title":"Code Example","text":"<p>Here\u2019s a simple example in Java (the concept is very similar in other OOP languages like C++, Python, etc.):</p>"},{"location":"oop/#class-car","title":"Class <code>Car</code>","text":"<pre><code>public class Car {\n    String model;\n    String color;\n\n    // Constructor\n    public Car(String model, String color) {\n        this.model = model;\n        this.color = color;\n    }\n\n    // Method to start the car\n    public void startCar() {\n        System.out.println(model + \" is starting.\");\n    }\n\n    // Method to turn off the car\n    public void turnOffCar() {\n        System.out.println(model + \" is turning off.\");\n    }\n}\n</code></pre>"},{"location":"oop/#class-main","title":"Class <code>Main</code>","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n        Car myCar = new Car(\"VW Golf\", \"Rot\");\n        myCar.startCar();\n        myCar.turnOffCar();\n    }\n}\n</code></pre>"},{"location":"osi/","title":"Infrastructure - OSI Model","text":""},{"location":"osi/#the-osi-model","title":"The OSI Model","text":""},{"location":"osi/#first-layer","title":"First Layer:","text":"<ul> <li>This is the physical layer. It contains things like Cables, Keyboards, etc.</li> </ul>"},{"location":"osi/#second-layer","title":"Second Layer:","text":"<ul> <li>The data link layer takes the data bits and \u201cframes\", and creates packets of the data to guarantee reliable transmission.</li> <li>This layer adds source and destination addresses to the data stream (MAC Address for example) as well as information to detect and control transmission errors. </li> </ul>"},{"location":"osi/#third-layer","title":"Third Layer:","text":"<ul> <li>The network layer is responsible for receiving frames from the data link layer, and delivering them to their intended destinations based on the addresses contained inside the frame. </li> <li>The network layer finds the destination by using logical addresses, such as IP (internet protocol). At this layer, routers are a crucial component used to quite literally route information where it needs to go between networks.</li> <li>(Also see picture at the end)</li> </ul>"},{"location":"osi/#fourth-layer","title":"Fourth Layer:","text":"<p>This layer is about the transport with TCP or UDP.</p>"},{"location":"osi/#tcp","title":"TCP:","text":"<ul> <li>Guarantees a safe and complete transport of the package</li> <li>Contains alarm system if something gets lost, etc.</li> <li>Sends and waits for response, after response sends the next message and so on</li> <li>Isn't practical for real-time connections such as live streams, phone calls, etc.</li> </ul>"},{"location":"osi/#udp","title":"UDP:","text":"<ul> <li>Doesn't wait for a response - sends message for message and hopes that receiver gets it</li> <li>If something doesn't reach the receiver UDP just sends it again</li> <li>Better for real-time connections such as livestreams, etc. for less delay</li> </ul>"},{"location":"osi/#fifth-layer","title":"Fifth Layer:","text":"<ul> <li>This layer is for sessions, so that the user doesn't have to log in or request a new token every time for example.</li> </ul>"},{"location":"osi/#sixth-layer","title":"Sixth Layer:","text":"<ul> <li>Formates data so that it becomes usable</li> </ul>"},{"location":"osi/#seventh-layer","title":"Seventh Layer:","text":"<ul> <li>UI, Browser, etc.</li> </ul>"},{"location":"osi/#notes","title":"Notes","text":""},{"location":"platform/","title":"Platform","text":""},{"location":"platform/#mise","title":"Mise","text":"<p>Mise is a handy terminal tool, which helps me to always install the version of java, etc. I wants.</p>"},{"location":"platform/#tutorial","title":"Tutorial","text":"<ol> <li>Go to the file mise.toml</li> <li>Define in the file what I want to install and which version</li> <li>For example: java = 'openjdk-17.0.2'</li> <li>Go to the terminal and type in \"mise install\"</li> <li>Now it installed everything I defined in that file</li> </ol>"},{"location":"platform/#other-commands","title":"Other commands","text":"<ul> <li>\"mise plugins ls-remote\" = shows list of all options to install</li> <li>\"mise ls-remote java\" = shows all available version of for example java</li> <li>Example: \"mise ls-remote java\" = all java versions you can install</li> </ul>"},{"location":"platform/#direnv","title":"DirenV","text":"<p>Direnv is a terminal tool that automatically loads / unloads environment variables based on the directory I'm in.</p>"},{"location":"platform/#tutorial_1","title":"Tutorial","text":"<ol> <li>Create a \".envrc\" file (never commit this file for safety reasons)</li> <li>Define everything in there like keys, etc.</li> <li>Example: export TEST_TOKEN=Token_test123456</li> <li>Go to the terminal and type in \"direnv allow\"</li> <li>Now everything is updated</li> </ol>"},{"location":"platform/#useful-commands","title":"Useful commands","text":"<ul> <li>To build: \"npx nx run \u201cname\u201d:build\" \u2014&gt; building what I wanted to be built</li> </ul>"},{"location":"vim/","title":"Vim - Terminal","text":""},{"location":"vim/#basic-commands","title":"Basic commands:","text":"<ul> <li>Create File (Example): vim ~/.gitconfig-name</li> <li>Insert: Press i to enter insert mode.</li> <li>Edit: In insert mode, you can type normally.</li> <li>Exit mode: Press Esc to return to normal mode.</li> <li>Save: In normal mode, type :w and press Enter.</li> <li>Exit: Type :q and press Enter or combine both with :wq to save and exit.</li> </ul>"}]}